<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>„Éî„ÇØ„Çª„É´„Ç¢„Éº„Éà„Ç®„Éá„Ç£„Çø</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
    }
    
    .container {
      display: flex;
      height: 100vh;
      gap: 16px;
      padding: 16px;
    }
    
    .panel {
      background: #2a2a2a;
      border-radius: 8px;
      padding: 16px;
      overflow-y: auto;
    }
    
    .left-panel {
      width: 280px;
    }
    
    .right-panel {
      width: 280px;
    }
    
    .center {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
    }
    
    h2, h3 {
      margin-bottom: 16px;
    }
    
    .section {
      margin-bottom: 24px;
    }
    
    .tool-btn, .layer-item, .frame-item {
      width: 100%;
      padding: 10px;
      margin-bottom: 8px;
      background: #3a3a3a;
      border: none;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      transition: background 0.2s;
    }
    
    .tool-btn:hover, .layer-item:hover, .frame-item:hover {
      background: #4a4a4a;
    }
    
    .tool-btn.active {
      background: #3b82f6;
    }
    
    .layer-item.active, .frame-item.active {
      background: #3b82f6;
    }
    
    .color-input {
      width: 100%;
      height: 50px;
      border-radius: 6px;
      border: 2px solid #3a3a3a;
      cursor: grab;
    }
    
    .color-input:active {
      cursor: grabbing;
    }
    
    .palette {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-top: 8px;
    }
    
    .palette-color {
      position: relative;
      width: 100%;
      height: 50px;
      border-radius: 6px;
      border: 2px solid #3a3a3a;
      cursor: grab;
      transition: border-color 0.2s;
    }
    
    .palette-color:active {
      cursor: grabbing;
    }
    
    .palette-color.active {
      border-color: #fff;
    }
    
    .palette-color-delete {
      position: absolute;
      top: 2px;
      right: 2px;
      background: rgba(220, 38, 38, 0.9);
      border: none;
      color: white;
      width: 18px;
      height: 18px;
      border-radius: 3px;
      font-size: 12px;
      cursor: pointer;
      display: none;
    }
    
    .palette-color:hover .palette-color-delete {
      display: block;
    }
    
    .slider-group {
      margin: 16px 0;
    }
    
    .slider-group label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: #3a3a3a;
      outline: none;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 12px 0;
    }
    
    .btn-group {
      display: flex;
      gap: 8px;
    }
    
    .icon-btn {
      flex: 1;
      padding: 10px;
      background: #3a3a3a;
      border: none;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .icon-btn:hover {
      background: #4a4a4a;
    }
    
    .icon-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .icon-btn.danger {
      background: #dc2626;
    }
    
    .icon-btn.success {
      background: #16a34a;
    }
    
    .canvas-wrapper {
      position: relative;
      display: inline-block;
    }
    
    canvas {
      border: 2px solid #3a3a3a;
      cursor: crosshair;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      display: block;
    }
    
    .layer-content, .frame-content {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .layer-name, .frame-name {
      flex: 1;
      text-align: left;
      background: transparent;
      border: none;
      color: #fff;
      padding: 0;
      font-size: inherit;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    .layer-name:focus, .frame-name:focus {
      outline: 1px solid #3b82f6;
      cursor: text;
    }
    
    .eye-btn, .delete-btn, .move-btn {
      background: none;
      border: none;
      color: #fff;
      cursor: pointer;
      padding: 4px;
      font-size: 16px;
    }
    
    .move-btn {
      cursor: grab;
    }
    
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    
    .add-btn {
      background: #3a3a3a;
      border: none;
      color: #fff;
      width: 32px;
      height: 32px;
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    select {
      width: 100%;
      padding: 10px;
      background: #3a3a3a;
      border: 1px solid #4a4a4a;
      border-radius: 6px;
      color: #fff;
      cursor: pointer;
      margin-bottom: 12px;
    }
    
    .selection-overlay {
      position: absolute;
      border: 2px dashed #3b82f6;
      background: rgba(59, 130, 246, 0.1);
      pointer-events: none;
    }
    
    small {
      color: #888;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left Panel -->
    <div class="panel left-panel">
      <h2>„ÉÑ„Éº„É´</h2>
      
      <div class="section">
        <button class="tool-btn active" data-tool="pen">„Éö„É≥</button>
        <button class="tool-btn" data-tool="eraser">Ê∂à„Åó„Ç¥„É†</button>
        <button class="tool-btn" data-tool="fill">Â°ó„Çä„Å§„Å∂„Åó</button>
        <button class="tool-btn" data-tool="eyedropper">„Çπ„Éù„Ç§„Éà</button>
        <button class="tool-btn" data-tool="line">Áõ¥Á∑ö</button>
        <button class="tool-btn" data-tool="rect">ÂõõËßíÂΩ¢</button>
        <button class="tool-btn" data-tool="rect-filled">Â°ó„Çä„Å§„Å∂„ÅóÂõõËßí</button>
      </div>

      <div class="section">
        <label>„Ç´„É©„ÉºÔºà„Éâ„É©„ÉÉ„Ç∞„ÅßÂ°ó„Çä„Å§„Å∂„ÅóÔºâ</label>
        <input type="color" class="color-input" id="colorPicker" value="#000000" draggable="true">
        <button class="tool-btn" id="addToPalette" style="margin-top: 8px;">„Éë„É¨„ÉÉ„Éà„Å´ËøΩÂä†</button>
      </div>

      <div class="section">
        <label>„Éë„É¨„ÉÉ„ÉàÔºà„ÇØ„É™„ÉÉ„ÇØÈÅ∏Êäû/„Éâ„É©„ÉÉ„Ç∞„ÅßÂ°ó„Çä„Å§„Å∂„ÅóÔºâ</label>
        <div class="palette" id="palette"></div>
      </div>

      <div class="section">
        <label>ËÉåÊôØËâ≤</label>
        <input type="color" class="color-input" id="bgColorPicker" value="#2a2a2a">
      </div>

      <div class="section">
        <label>„Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫</label>
        <select id="canvasSize">
          <option value="8">8 √ó 8</option>
          <option value="16">16 √ó 16</option>
          <option value="24">24 √ó 24</option>
          <option value="32" selected>32 √ó 32</option>
          <option value="48">48 √ó 48</option>
          <option value="64">64 √ó 64</option>
          <option value="96">96 √ó 96</option>
          <option value="128">128 √ó 128</option>
        </select>
      </div>

      <div class="slider-group">
        <label>„Ç∫„Éº„É†: <span id="zoomValue">16</span>px</label>
        <input type="range" id="zoom" min="4" max="32" value="16">
      </div>

      <div class="checkbox-group">
        <input type="checkbox" id="showGrid" checked>
        <label for="showGrid">„Ç∞„É™„ÉÉ„ÉâË°®Á§∫</label>
      </div>

      <div class="btn-group">
        <button class="icon-btn" id="undo" disabled>‚Ü∂</button>
        <button class="icon-btn" id="redo" disabled>‚Ü∑</button>
      </div>

      <div class="btn-group" style="margin-top: 8px;">
        <button class="icon-btn" id="flipH" title="Â∑¶Âè≥ÂèçËª¢">‚áÑ</button>
        <button class="icon-btn" id="flipV" title="‰∏ä‰∏ãÂèçËª¢">‚áÖ</button>
      </div>

      <div class="btn-group" style="margin-top: 16px;">
        <button class="icon-btn danger" id="clear">„ÇØ„É™„Ç¢</button>
        <button class="icon-btn success" id="export">‰øùÂ≠ò</button>
      </div>

      <div style="margin-top: 16px;">
        <small>Âè≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÁØÑÂõ≤ÈÅ∏Êäû<br>Ctrl+C/X/V „Åß„Ç≥„Éî„Éº/„Ç´„ÉÉ„Éà/„Éö„Éº„Çπ„Éà<br>Ctrl+Z/Y „ÅßÂÖÉ„Å´Êàª„Åô/„ÇÑ„ÇäÁõ¥„Åô</small>
      </div>
    </div>

    <!-- Center Canvas -->
    <div class="center" id="centerPanel">
      <div class="canvas-wrapper">
        <canvas id="canvas"></canvas>
        <div id="selectionOverlay" class="selection-overlay" style="display: none;"></div>
      </div>
    </div>

    <!-- Right Panel -->
    <div class="panel right-panel">
      <div class="section">
        <div class="header-row">
          <h3>„Éï„É¨„Éº„É†</h3>
          <button class="icon-btn" id="playPause" style="width: auto; padding: 8px 12px;">‚ñ∂</button>
        </div>
        <div id="framesList"></div>
        <button class="tool-btn" id="addFrame">+ „Éï„É¨„Éº„É†ËøΩÂä†</button>
        
        <div class="slider-group">
          <label>FPS: <span id="fpsValue">8</span></label>
          <input type="range" id="fps" min="1" max="24" value="8">
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="onionSkin">
          <label for="onionSkin">„Ç™„Éã„Ç™„É≥„Çπ„Ç≠„É≥</label>
        </div>
      </div>

      <div class="section">
        <div class="header-row">
          <h3>„É¨„Ç§„É§„Éº</h3>
          <button class="add-btn" id="addLayer">+</button>
        </div>
        <div id="layersList"></div>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEY = 'pixelArtEditorState';
    
    let canvasSize = 32;
    let zoom = 16;
    let showGrid = true;
    let tool = 'pen';
    let color = '#000000';
    let bgColor = '#2a2a2a';
    let palette = ['#FFFFFF', '#000000'];
    
    let layers = [{ id: 1, name: '„É¨„Ç§„É§„Éº', visible: true, opacity: 1, data: Array(32 * 32).fill(null) }];
    let activeLayerId = 1;
    
    let frames = [{ id: 1, name: '„Éï„É¨„Éº„É†', layers: JSON.parse(JSON.stringify(layers)) }];
    let activeFrameId = 1;
    let isPlaying = false;
    let fps = 8;
    let showOnionSkin = false;
    
    let history = [];
    let historyIndex = -1;
    
    let isDrawing = false;
    let isSelecting = false;
    let startPos = null;
    let selection = null;
    let clipboard = null;
    let animationInterval = null;
    let lastMousePos = { x: 0, y: 0 };
    let draggedColor = null;

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const selectionOverlay = document.getElementById('selectionOverlay');
    const centerPanel = document.getElementById('centerPanel');

    // Load saved state
    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const state = JSON.parse(saved);
          canvasSize = state.canvasSize || 32;
          zoom = state.zoom || 16;
          showGrid = state.showGrid !== undefined ? state.showGrid : true;
          color = state.color || '#000000';
          bgColor = state.bgColor || '#2a2a2a';
          palette = state.palette || ['#FFFFFF', '#000000'];
          frames = state.frames || frames;
          activeFrameId = state.activeFrameId || 1;
          fps = state.fps || 8;
          
          document.getElementById('canvasSize').value = canvasSize;
          document.getElementById('zoom').value = zoom;
          document.getElementById('zoomValue').textContent = zoom;
          document.getElementById('showGrid').checked = showGrid;
          document.getElementById('colorPicker').value = color;
          document.getElementById('bgColorPicker').value = bgColor;
          document.getElementById('fps').value = fps;
          document.getElementById('fpsValue').textContent = fps;
          centerPanel.style.background = bgColor;
          
          updateFromActiveFrame();
          renderPalette();
        }
      } catch (e) {
        console.error('Failed to load state:', e);
      }
    }

    // Save state
    function saveState() {
      try {
        const state = {
          canvasSize,
          zoom,
          showGrid,
          color,
          bgColor,
          palette,
          frames,
          activeFrameId,
          fps
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {
        console.error('Failed to save state:', e);
      }
    }

    // Auto-save every 2 seconds
    setInterval(saveState, 2000);

    function updateFromActiveFrame() {
      const frame = frames.find(f => f.id === activeFrameId);
      if (frame) {
        layers = JSON.parse(JSON.stringify(frame.layers));
        if (layers.length > 0 && !layers.find(l => l.id === activeLayerId)) {
          activeLayerId = layers[0].id;
        }
      }
    }

    function initCanvas() {
      canvas.width = canvasSize * zoom;
      canvas.height = canvasSize * zoom;
      drawCanvas();
    }

    function drawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Onion skin
      if (showOnionSkin && frames.length > 1) {
        const currentIndex = frames.findIndex(f => f.id === activeFrameId);
        const prevIndex = currentIndex > 0 ? currentIndex - 1 : frames.length - 1;
        const prevFrame = frames[prevIndex];
        
        prevFrame.layers.forEach(layer => {
          if (layer.visible) {
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < layer.data.length; i++) {
              if (layer.data[i]) {
                const x = i % canvasSize;
                const y = Math.floor(i / canvasSize);
                ctx.fillStyle = layer.data[i];
                ctx.fillRect(x * zoom, y * zoom, zoom, zoom);
              }
            }
          }
        });
      }
      
      // Current frame
      layers.forEach(layer => {
        if (layer.visible) {
          ctx.globalAlpha = layer.opacity;
          for (let i = 0; i < layer.data.length; i++) {
            if (layer.data[i]) {
              const x = i % canvasSize;
              const y = Math.floor(i / canvasSize);
              ctx.fillStyle = layer.data[i];
              ctx.fillRect(x * zoom, y * zoom, zoom, zoom);
            }
          }
        }
      });
      
      ctx.globalAlpha = 1;
      
      // Grid
      if (showGrid) {
        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        for (let i = 0; i <= canvasSize; i++) {
          ctx.beginPath();
          ctx.moveTo(i * zoom, 0);
          ctx.lineTo(i * zoom, canvasSize * zoom);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(0, i * zoom);
          ctx.lineTo(canvasSize * zoom, i * zoom);
          ctx.stroke();
        }
      }
    }

    function getPixelPos(e) {
      const rect = canvas.getBoundingClientRect();
      const x = Math.floor((e.clientX - rect.left) / zoom);
      const y = Math.floor((e.clientY - rect.top) / zoom);
      return { x, y };
    }

    function setPixel(x, y, pixelColor) {
      if (x < 0 || x >= canvasSize || y < 0 || y >= canvasSize) return;
      
      const index = y * canvasSize + x;
      const layerIndex = layers.findIndex(l => l.id === activeLayerId);
      if (layerIndex !== -1) {
        layers[layerIndex].data[index] = pixelColor;
        
        const frameIndex = frames.findIndex(f => f.id === activeFrameId);
        frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
        drawCanvas();
      }
    }

    function floodFill(startX, startY, targetColor, fillColor) {
      if (targetColor === fillColor) return;
      
      const layerIndex = layers.findIndex(l => l.id === activeLayerId);
      if (layerIndex === -1) return;
      
      const data = [...layers[layerIndex].data];
      const stack = [[startX, startY]];
      
      while (stack.length > 0) {
        const [x, y] = stack.pop();
        if (x < 0 || x >= canvasSize || y < 0 || y >= canvasSize) continue;
        
        const index = y * canvasSize + x;
        if (data[index] === targetColor) {
          data[index] = fillColor;
          stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
        }
      }
      
      layers[layerIndex].data = data;
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      drawCanvas();
    }

    function drawLine(x0, y0, x1, y1) {
      const dx = Math.abs(x1 - x0);
      const dy = Math.abs(y1 - y0);
      const sx = x0 < x1 ? 1 : -1;
      const sy = y0 < y1 ? 1 : -1;
      let err = dx - dy;

      while (true) {
        setPixel(x0, y0, tool === 'eraser' ? null : color);
        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; x0 += sx; }
        if (e2 < dx) { err += dx; y0 += sy; }
      }
    }

    function drawRect(x0, y0, x1, y1, filled = false) {
      const minX = Math.min(x0, x1);
      const maxX = Math.max(x0, x1);
      const minY = Math.min(y0, y1);
      const maxY = Math.max(y0, y1);

      if (filled) {
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            setPixel(x, y, color);
          }
        }
      } else {
        for (let x = minX; x <= maxX; x++) {
          setPixel(x, minY, color);
          setPixel(x, maxY, color);
        }
        for (let y = minY; y <= maxY; y++) {
          setPixel(minX, y, color);
          setPixel(maxX, y, color);
        }
      }
    }

    function saveToHistory() {
      const newHistory = history.slice(0, historyIndex + 1);
      newHistory.push(JSON.parse(JSON.stringify(frames)));
      history = newHistory;
      historyIndex = newHistory.length - 1;
      updateUndoRedo();
    }

    function updateUndoRedo() {
      document.getElementById('undo').disabled = historyIndex <= 0;
      document.getElementById('redo').disabled = historyIndex >= history.length - 1;
    }

    function updateSelection(x, y) {
      if (!selection) return;
      
      const minX = Math.min(selection.startX, x);
      const maxX = Math.max(selection.startX, x);
      const minY = Math.min(selection.startY, y);
      const maxY = Math.max(selection.startY, y);
      
      selectionOverlay.style.display = 'block';
      selectionOverlay.style.left = (minX * zoom) + 'px';
      selectionOverlay.style.top = (minY * zoom) + 'px';
      selectionOverlay.style.width = ((maxX - minX + 1) * zoom) + 'px';
      selectionOverlay.style.height = ((maxY - minY + 1) * zoom) + 'px';
      
      selection.minX = minX;
      selection.maxX = maxX;
      selection.minY = minY;
      selection.maxY = maxY;
    }

    function copySelection() {
      if (!selection) return;
      
      const layerIndex = layers.findIndex(l => l.id === activeLayerId);
      if (layerIndex === -1) return;
      
      const width = selection.maxX - selection.minX + 1;
      const height = selection.maxY - selection.minY + 1;
      const data = [];
      
      for (let y = selection.minY; y <= selection.maxY; y++) {
        for (let x = selection.minX; x <= selection.maxX; x++) {
          const index = y * canvasSize + x;
          data.push(layers[layerIndex].data[index]);
        }
      }
      
      clipboard = { width, height, data };
      
    }

    function cutSelection() {
      if (!selection) return;
      copySelection();
      
      saveToHistory();
      const layerIndex = layers.findIndex(l => l.id === activeLayerId);
      if (layerIndex === -1) return;
      
      for (let y = selection.minY; y <= selection.maxY; y++) {
        for (let x = selection.minX; x <= selection.maxX; x++) {
          const index = y * canvasSize + x;
          layers[layerIndex].data[index] = null;
        }
      }
      
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      drawCanvas();
    }

    function pasteClipboard(atX, atY) {
      if (!clipboard) return;
      
      saveToHistory();
      const layerIndex = layers.findIndex(l => l.id === activeLayerId);
      if (layerIndex === -1) return;
      
      let idx = 0;
      for (let y = 0; y < clipboard.height; y++) {
        for (let x = 0; x < clipboard.width; x++) {
          const targetX = atX + x;
          const targetY = atY + y;
          if (targetX >= 0 && targetX < canvasSize && targetY >= 0 && targetY < canvasSize) {
            const index = targetY * canvasSize + targetX;
            if (clipboard.data[idx] !== null) {
              layers[layerIndex].data[index] = clipboard.data[idx];
            }
          }
          idx++;
        }
      }
      
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      drawCanvas();

      // Clear selection
      selection = null;
      selectionOverlay.style.display = 'none';
    }

    // Event handlers
    canvas.addEventListener('mousedown', (e) => {
      const pos = getPixelPos(e);
      
      if (e.button === 2) { // Right click
        e.preventDefault();
        isSelecting = true;
        selection = { startX: pos.x, startY: pos.y };
        return;
      }
      
      if (e.button !== 0) return; // Only left click
      
      isDrawing = true;
      startPos = pos;
      
      if (tool === 'pen' || tool === 'eraser') {
        setPixel(pos.x, pos.y, tool === 'eraser' ? null : color);
      } else if (tool === 'fill') {
        saveToHistory();
        const activeLayer = layers.find(l => l.id === activeLayerId);
        const index = pos.y * canvasSize + pos.x;
        const targetColor = activeLayer.data[index];
        floodFill(pos.x, pos.y, targetColor, color);
      } else if (tool === 'eyedropper') {
        const activeLayer = layers.find(l => l.id === activeLayerId);
        const index = pos.y * canvasSize + pos.x;
        const pickedColor = activeLayer.data[index];
        if (pickedColor) {
          color = pickedColor;
          document.getElementById('colorPicker').value = color;
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const pos = getPixelPos(e);
      lastMousePos = pos;
      
      if (isSelecting) {
        updateSelection(pos.x, pos.y);
        return;
      }
      
      if (!isDrawing) return;
      
      if (tool === 'pen' || tool === 'eraser') {
        setPixel(pos.x, pos.y, tool === 'eraser' ? null : color);
      }
    });

    canvas.addEventListener('mouseup', (e) => {
      if (isSelecting) {
        isSelecting = false;
        return;
      }
      
      if (!isDrawing) return;
„ÄÄ„ÄÄ„ÄÄsaveToHistory();
      const pos = getPixelPos(e);
      
      if (tool === 'line') {
        drawLine(startPos.x, startPos.y, pos.x, pos.y);
      } else if (tool === 'rect') {
        drawRect(startPos.x, startPos.y, pos.x, pos.y, false);
      } else if (tool === 'rect-filled') {
        drawRect(startPos.x, startPos.y, pos.x, pos.y, true);
      }
      
      isDrawing = false;
      startPos = null;
    });

    canvas.addEventListener('mouseleave', () => {
      isDrawing = false;
      isSelecting = false;
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // Drag and drop color to canvas
    canvas.addEventListener('dragover', (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'copy';
    });

    canvas.addEventListener('drop', (e) => {
      e.preventDefault();
      if (draggedColor) {
        const pos = getPixelPos(e);
        saveToHistory();
        const activeLayer = layers.find(l => l.id === activeLayerId);
        const index = pos.y * canvasSize + pos.x;
        const targetColor = activeLayer.data[index];
        floodFill(pos.x, pos.y, targetColor, draggedColor);
        draggedColor = null;
      }
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'z') {
          e.preventDefault();
          if (historyIndex > 0) {
            historyIndex--;
            frames = JSON.parse(JSON.stringify(history[historyIndex]));
            updateFromActiveFrame();
            drawCanvas();
            updateUndoRedo();
            renderFrames();
            renderLayers();
          }
        } else if (e.key === 'y') {
          e.preventDefault();
          if (historyIndex < history.length - 1) {
            historyIndex++;
            frames = JSON.parse(JSON.stringify(history[historyIndex]));
            updateFromActiveFrame();
            drawCanvas();
            updateUndoRedo();
            renderFrames();
            renderLayers();
          }
        } else if (e.key === 'c') {
          e.preventDefault();
          copySelection();
        } else if (e.key === 'x') {
          e.preventDefault();
          cutSelection();
        } else if (e.key === 'v') {
          e.preventDefault();
          if (clipboard) {
            pasteClipboard(lastMousePos.x, lastMousePos.y);
          }
        }
      }
    });

    // Tool buttons
    document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
      btn.addEventListener('click', () => {
        tool = btn.dataset.tool;
        document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
      });
    });

    // Color picker
    document.getElementById('colorPicker').addEventListener('input', (e) => {
      color = e.target.value;
    });

    // Color picker drag
    document.getElementById('colorPicker').addEventListener('dragstart', (e) => {
      draggedColor = color;
    });

    document.getElementById('colorPicker').addEventListener('dragend', () => {
      draggedColor = null;
    });

    // Background color picker
    document.getElementById('bgColorPicker').addEventListener('input', (e) => {
      bgColor = e.target.value;
      centerPanel.style.background = bgColor;
      saveState();
    });

    // Add to palette
    document.getElementById('addToPalette').addEventListener('click', () => {
      if (!palette.includes(color)) {
        palette.push(color);
        renderPalette();
        saveState();
      }
    });

    function renderPalette() {
      const paletteEl = document.getElementById('palette');
      paletteEl.innerHTML = '';
      palette.forEach((c, index) => {
        const wrapper = document.createElement('div');
        wrapper.className = 'palette-color';
        if (c === color) wrapper.classList.add('active');
        wrapper.style.backgroundColor = c;
        wrapper.draggable = true;
        
        wrapper.addEventListener('click', () => {
          color = c;
          document.getElementById('colorPicker').value = c;
          renderPalette();
        });
        
        wrapper.addEventListener('dragstart', (e) => {
          draggedColor = c;
        });
        
        wrapper.addEventListener('dragend', () => {
          draggedColor = null;
        });
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'palette-color-delete';
        deleteBtn.textContent = '√ó';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          palette.splice(index, 1);
          renderPalette();
          saveState();
        });
        
        wrapper.appendChild(deleteBtn);
        paletteEl.appendChild(wrapper);
      });
    }

    // Canvas size
    document.getElementById('canvasSize').addEventListener('change', (e) => {
      const newSize = parseInt(e.target.value);
      
      // Resize all layers in all frames
      frames = frames.map(frame => ({
        ...frame,
        layers: frame.layers.map(layer => {
          const newData = Array(newSize * newSize).fill(null);
          const copySize = Math.min(canvasSize, newSize);
          
          for (let y = 0; y < copySize; y++) {
            for (let x = 0; x < copySize; x++) {
              const oldIndex = y * canvasSize + x;
              const newIndex = y * newSize + x;
              newData[newIndex] = layer.data[oldIndex];
            }
          }
          
          return { ...layer, data: newData };
        })
      }));
      
      canvasSize = newSize;
      updateFromActiveFrame();
      initCanvas();
      renderFrames();
      renderLayers();
      saveState();
    });

    // Zoom
    document.getElementById('zoom').addEventListener('input', (e) => {
      zoom = parseInt(e.target.value);
      document.getElementById('zoomValue').textContent = zoom;
      initCanvas();
    });

    // Grid
    document.getElementById('showGrid').addEventListener('change', (e) => {
      showGrid = e.target.checked;
      drawCanvas();
    });

    // Undo/Redo
    document.getElementById('undo').addEventListener('click', () => {
      if (historyIndex > 0) {
        historyIndex--;
        frames = JSON.parse(JSON.stringify(history[historyIndex]));
        updateFromActiveFrame();
        drawCanvas();
        updateUndoRedo();
        renderFrames();
        renderLayers();
      }
    });

    document.getElementById('redo').addEventListener('click', () => {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        frames = JSON.parse(JSON.stringify(history[historyIndex]));
        updateFromActiveFrame();
        drawCanvas();
        updateUndoRedo();
        renderFrames();
        renderLayers();
      }
    });

    // Flip
    document.getElementById('flipH').addEventListener('click', () => {
      saveToHistory();
      layers = layers.map(layer => {
        const newData = [...layer.data];
        for (let y = 0; y < canvasSize; y++) {
          for (let x = 0; x < canvasSize / 2; x++) {
            const leftIndex = y * canvasSize + x;
            const rightIndex = y * canvasSize + (canvasSize - 1 - x);
            [newData[leftIndex], newData[rightIndex]] = [newData[rightIndex], newData[leftIndex]];
          }
        }
        return { ...layer, data: newData };
      });
      
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      drawCanvas();
    });

    document.getElementById('flipV').addEventListener('click', () => {
      saveToHistory();
      layers = layers.map(layer => {
        const newData = [...layer.data];
        for (let y = 0; y < canvasSize / 2; y++) {
          for (let x = 0; x < canvasSize; x++) {
            const topIndex = y * canvasSize + x;
            const bottomIndex = (canvasSize - 1 - y) * canvasSize + x;
            [newData[topIndex], newData[bottomIndex]] = [newData[bottomIndex], newData[topIndex]];
          }
        }
        return { ...layer, data: newData };
      });
      
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      drawCanvas();
    });

    // Clear
    document.getElementById('clear').addEventListener('click', () => {
      if (confirm('„Ç≠„É£„É≥„Éê„Çπ„Çí„ÇØ„É™„Ç¢„Åó„Åæ„Åô„Åã?')) {
        saveToHistory();
        const newLayers = layers.map(l => ({
          ...l,
          data: Array(canvasSize * canvasSize).fill(null)
        }));
        layers = newLayers;
        
        const frameIndex = frames.findIndex(f => f.id === activeFrameId);
        frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
        drawCanvas();
      }
    });

    // Export PNG
    document.getElementById('export').addEventListener('click', () => {
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = canvasSize;
      exportCanvas.height = canvasSize;
      const exportCtx = exportCanvas.getContext('2d');
      
      layers.forEach(layer => {
        if (layer.visible) {
          exportCtx.globalAlpha = layer.opacity;
          for (let i = 0; i < layer.data.length; i++) {
            if (layer.data[i]) {
              const x = i % canvasSize;
              const y = Math.floor(i / canvasSize);
              exportCtx.fillStyle = layer.data[i];
              exportCtx.fillRect(x, y, 1, 1);
            }
          }
        }
      });
      
      exportCanvas.toBlob(blob => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pixel-art.png';
        a.click();
      });
    });

    // Frames
    function renderFrames() {
      const list = document.getElementById('framesList');
      list.innerHTML = '';
      
      frames.forEach((frame, index) => {
        const div = document.createElement('div');
        div.className = 'frame-item';
        if (frame.id === activeFrameId) div.classList.add('active');
        
        const content = document.createElement('div');
        content.className = 'frame-content';
        
        const moveBtn = document.createElement('button');
        moveBtn.className = 'move-btn';
        moveBtn.textContent = '‚ò∞';
        moveBtn.title = '„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶‰∏¶„Å≥Êõø„Åà';
        
        const name = document.createElement('input');
        name.type = 'text';
        name.className = 'frame-name';
        name.value = frame.name;
        name.addEventListener('click', (e) => {
          if (frame.id !== activeFrameId) {
            activeFrameId = frame.id;
            updateFromActiveFrame();
            drawCanvas();
            renderFrames();
            renderLayers();
          }
        });
        name.addEventListener('change', (e) => {
          frame.name = e.target.value;
          saveState();
        });
        name.addEventListener('blur', () => {
          if (!frame.name.trim()) {
            frame.name = '„Éï„É¨„Éº„É†';
            renderFrames();
          }
        });
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'üóë';
        deleteBtn.title = 'ÂâäÈô§';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (frames.length > 1 && confirm(`${frame.name}„ÇíÂâäÈô§„Åó„Åæ„Åô„Åã?`)) {
            saveToHistory();
            frames = frames.filter(f => f.id !== frame.id);
            if (activeFrameId === frame.id) {
              activeFrameId = frames[0].id;
              updateFromActiveFrame();
            }
            renderFrames();
            drawCanvas();
          } else if (frames.length === 1) {
            alert('ÊúÄÂæå„ÅÆ„Éï„É¨„Éº„É†„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
          }
        });
        
        content.appendChild(moveBtn);
        content.appendChild(name);
        content.appendChild(deleteBtn);
        div.appendChild(content);
        list.appendChild(div);
        
        // Drag and drop
        div.draggable = true;
        div.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', index);
        });
        
        div.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        div.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          
          if (fromIndex !== toIndex) {
            saveToHistory();
            const [movedFrame] = frames.splice(fromIndex, 1);
            frames.splice(toIndex, 0, movedFrame);
            renderFrames();
          }
        });
      });
    }

    document.getElementById('addFrame').addEventListener('click', () => {
      const newId = Math.max(...frames.map(f => f.id)) + 1;
      const newFrame = {
        id: newId,
        name: '„Éï„É¨„Éº„É†',
        layers: [{ 
          id: 1, 
          name: '„É¨„Ç§„É§„Éº', 
          visible: true, 
          opacity: 1, 
          data: Array(canvasSize * canvasSize).fill(null) 
        }]
      };
      frames.push(newFrame);
      activeFrameId = newId;
      updateFromActiveFrame();
      saveToHistory();
      renderFrames();
      renderLayers();
      drawCanvas();
    });

    // Animation
    document.getElementById('playPause').addEventListener('click', () => {
      isPlaying = !isPlaying;
      document.getElementById('playPause').textContent = isPlaying ? '‚è∏' : '‚ñ∂';
      
      if (isPlaying) {
        let currentIndex = frames.findIndex(f => f.id === activeFrameId);
        animationInterval = setInterval(() => {
          currentIndex = (currentIndex + 1) % frames.length;
          activeFrameId = frames[currentIndex].id;
          updateFromActiveFrame();
          drawCanvas();
          renderFrames();
          renderLayers();
        }, 1000 / fps);
      } else {
        if (animationInterval) {
          clearInterval(animationInterval);
          animationInterval = null;
        }
      }
    });

    document.getElementById('fps').addEventListener('input', (e) => {
      fps = parseInt(e.target.value);
      document.getElementById('fpsValue').textContent = fps;
      
      if (isPlaying) {
        clearInterval(animationInterval);
        let currentIndex = frames.findIndex(f => f.id === activeFrameId);
        animationInterval = setInterval(() => {
          currentIndex = (currentIndex + 1) % frames.length;
          activeFrameId = frames[currentIndex].id;
          updateFromActiveFrame();
          drawCanvas();
          renderFrames();
          renderLayers();
        }, 1000 / fps);
      }
    });

    document.getElementById('onionSkin').addEventListener('change', (e) => {
      showOnionSkin = e.target.checked;
      drawCanvas();
    });

    // Layers
    function renderLayers() {
      const list = document.getElementById('layersList');
      list.innerHTML = '';
      
      [...layers].reverse().forEach((layer, reverseIndex) => {
        const index = layers.length - 1 - reverseIndex;
        
        const div = document.createElement('div');
        div.className = 'layer-item';
        if (layer.id === activeLayerId) div.classList.add('active');
        
        const content = document.createElement('div');
        content.className = 'layer-content';
        
        const moveBtn = document.createElement('button');
        moveBtn.className = 'move-btn';
        moveBtn.textContent = '‚ò∞';
        moveBtn.title = '„Éâ„É©„ÉÉ„Ç∞„Åó„Å¶‰∏¶„Å≥Êõø„Åà';
        
        const name = document.createElement('input');
        name.type = 'text';
        name.className = 'layer-name';
        name.value = layer.name;
        name.addEventListener('click', (e) => {
          if (layer.id !== activeLayerId) {
            activeLayerId = layer.id;
            renderLayers();
          }
        });
        name.addEventListener('change', (e) => {
          layer.name = e.target.value;
          const frameIndex = frames.findIndex(f => f.id === activeFrameId);
          frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
          saveState();
        });
        name.addEventListener('blur', () => {
          if (!layer.name.trim()) {
            layer.name = '„É¨„Ç§„É§„Éº';
            renderLayers();
          }
        });
        
        const eyeBtn = document.createElement('button');
        eyeBtn.className = 'eye-btn';
        eyeBtn.textContent = layer.visible ? 'üëÅ' : 'üëÅ‚Äçüó®';
        eyeBtn.title = 'Ë°®Á§∫/ÈùûË°®Á§∫';
        eyeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          layer.visible = !layer.visible;
          const frameIndex = frames.findIndex(f => f.id === activeFrameId);
          frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
          drawCanvas();
          renderLayers();
        });
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-btn';
        deleteBtn.textContent = 'üóë';
        deleteBtn.title = 'ÂâäÈô§';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (layers.length > 1 && confirm(`${layer.name}„ÇíÂâäÈô§„Åó„Åæ„Åô„Åã?`)) {
            saveToHistory();
            layers = layers.filter(l => l.id !== layer.id);
            if (activeLayerId === layer.id) {
              activeLayerId = layers[0].id;
            }
            const frameIndex = frames.findIndex(f => f.id === activeFrameId);
            frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
            renderLayers();
            drawCanvas();
          } else if (layers.length === 1) {
            alert('ÊúÄÂæå„ÅÆ„É¨„Ç§„É§„Éº„ÅØÂâäÈô§„Åß„Åç„Åæ„Åõ„Çì');
          }
        });
        
        content.appendChild(moveBtn);
        content.appendChild(name);
        content.appendChild(eyeBtn);
        content.appendChild(deleteBtn);
        div.appendChild(content);
        
        const opacitySlider = document.createElement('input');
        opacitySlider.type = 'range';
        opacitySlider.min = '0';
        opacitySlider.max = '1';
        opacitySlider.step = '0.1';
        opacitySlider.value = layer.opacity;
        opacitySlider.style.width = '100%';
        opacitySlider.style.marginTop = '4px';
        opacitySlider.addEventListener('input', (e) => {
          layer.opacity = parseFloat(e.target.value);
          const frameIndex = frames.findIndex(f => f.id === activeFrameId);
          frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
          drawCanvas();
        });
        div.appendChild(opacitySlider);
        
        list.appendChild(div);
        
        // Drag and drop
        div.draggable = true;
        div.addEventListener('dragstart', (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', index);
        });
        
        div.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
        });
        
        div.addEventListener('drop', (e) => {
          e.preventDefault();
          const fromIndex = parseInt(e.dataTransfer.getData('text/plain'));
          const toIndex = index;
          
          if (fromIndex !== toIndex) {
            saveToHistory();
            const [movedLayer] = layers.splice(fromIndex, 1);
            layers.splice(toIndex, 0, movedLayer);
            const frameIndex = frames.findIndex(f => f.id === activeFrameId);
            frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
            renderLayers();
            drawCanvas();
          }
        });
      });
    }

function initHistory() {
  history = [];
  historyIndex = -1;
  saveToHistory();
}

    document.getElementById('addLayer').addEventListener('click', () => {
      const newId = Math.max(...layers.map(l => l.id)) + 1;
      const newLayer = {
        id: newId,
        name: '„É¨„Ç§„É§„Éº',
        visible: true,
        opacity: 1,
        data: Array(canvasSize * canvasSize).fill(null)
      };
      layers.push(newLayer);
      activeLayerId = newId;
      
      const frameIndex = frames.findIndex(f => f.id === activeFrameId);
      frames[frameIndex].layers = JSON.parse(JSON.stringify(layers));
      saveToHistory();
      renderLayers();
      drawCanvas();
    });

    // Initialize
    loadState();
„ÄÄ„ÄÄinitHistory(); 
    initCanvas();
    renderPalette();
    renderFrames();
    renderLayers();
    updateUndoRedo();
  </script>
</body>
</html>
